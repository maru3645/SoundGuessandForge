<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>サウンド・ゲス・アンド・フォージ</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { font-family: 'Inter', sans-serif; user-select: none; }
        .module {
            border: 1px solid #ccc;
            background-color: #f9f9f9;
            padding: 10px;
            border-radius: 8px;
            position: absolute;
            cursor: grab;
            width: 150px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .module-title { font-weight: bold; margin-bottom: 5px; font-size: 0.9em; text-align: center; }
        .io-node {
            width: 12px;
            height: 12px;
            background-color: #3498db;
            border-radius: 50%;
            position: absolute;
            cursor: pointer;
            border: 2px solid white;
        }
        .input-node { left: -8px; top: 50%; transform: translateY(-50%); background-color: #2ecc71;}
        .output-node { right: -8px; top: 50%; transform: translateY(-50%); background-color: #e74c3c;}
        .module .param-slider { width: 100%; }
        .module .param-label { font-size: 0.8em; margin-bottom: 2px; }
        #workspace {
            width: calc(100% - 200px - 230px - 20px); /* 画面幅 - 左パネル - 右パネル - gap */
            height: calc(100vh - 64px - 20px); /* 画面高さ - ヘッダー - gap */
            border: 1px solid #ddd;
            position: relative;
            overflow: hidden;
            background-color: #e9e9e9;
        }
        #module-palette { width: 200px; background-color: #f0f0f0; padding: 10px; }
        #param-editor { width: 230px; background-color: #f0f0f0; padding: 10px; overflow-y: auto;}
        .connection-line { stroke: #555; stroke-width: 3; fill: none; }
        .connection-line:hover { stroke: #e74c3c; cursor: pointer;} /* ホバー時のスタイルとカーソル */
        /* ボタン共通スタイル */
        .control-button {
            padding: 8px 16px;
            border-radius: 6px;
            background-color: #3498db;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s;
            border: none;
            margin: 5px;
        }
        .control-button:hover { background-color: #2980b9; }
        .control-button-red { background-color: #e74c3c; }
        .control-button-red:hover { background-color: #c0392b; }
        .control-button-green { background-color: #2ecc71; }
        .control-button-green:hover { background-color: #27ae60; }
        .control-button-gray { background-color: #95a5a6; }
        .control-button-gray:hover { background-color: #7f8c8d; }

        /* カスタムセレクトボックス */
        .custom-select {
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e");
            background-repeat: no-repeat;
            background-position: right 0.5rem center;
            background-size: 1.2em;
            padding-right: 2rem;
            border: 1px solid #ccc;
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 0.8em;
            width: 100%;
        }

    </style>
</head>
<body class="flex flex-col h-screen bg-gray-100 p-2.5">
    <!-- ヘッダー -->
    <header class="bg-slate-800 text-white p-3 shadow-md flex justify-between items-center rounded-t-lg">
        <h1 class="text-xl font-bold">サウンド・ゲス・アンド・フォージ</h1>
        <div id="global-controls">
            <button id="start-audio-button" class="control-button control-button-green">オーディオ開始</button>
            <button id="play-button" class="control-button" disabled>再生</button>
            <button id="stop-button" class="control-button control-button-red" disabled>停止</button>
            <button id="reset-button" class="control-button control-button-gray">リセット</button>
        </div>
    </header>

    <!-- メインコンテンツエリア -->
    <div class="flex flex-1 overflow-hidden gap-2.5 rounded-b-lg">
        <!-- 左: モジュールパレット -->
        <div id="module-palette" class="h-full overflow-y-auto rounded-bl-lg">
            <h2 class="text-lg font-semibold mb-3 p-2 bg-slate-200 rounded-md text-slate-700">モジュール</h2>
            <button data-type="oscillator" class="block w-full text-left p-2 mb-2 bg-blue-500 text-white rounded-md hover:bg-blue-600 transition-colors">オシレーター</button>
            <button data-type="gain" class="block w-full text-left p-2 mb-2 bg-green-500 text-white rounded-md hover:bg-green-600 transition-colors">ゲイン</button>
            <button data-type="filter" class="block w-full text-left p-2 mb-2 bg-yellow-500 text-white rounded-md hover:bg-yellow-600 transition-colors">フィルター</button>
            <button data-type="delay" class="block w-full text-left p-2 mb-2 bg-purple-500 text-white rounded-md hover:bg-purple-600 transition-colors">ディレイ</button>
            <button data-type="output" class="block w-full text-left p-2 mb-2 bg-gray-500 text-white rounded-md hover:bg-gray-600 transition-colors">アウトプット</button>
        </div>

        <!-- 中央: ワークスペース -->
        <div id="workspace" class="flex-1">
            <svg id="connections-svg" width="100%" height="100%" style="position: absolute; top: 0; left: 0; pointer-events: none;"></svg>
            <!-- モジュールはここに動的に追加されます -->
        </div>

        <!-- 右: パラメータエディタ -->
        <div id="param-editor" class="h-full overflow-y-auto rounded-br-lg">
            <h2 class="text-lg font-semibold mb-3 p-2 bg-slate-200 rounded-md text-slate-700">パラメータ</h2>
            <div id="editor-content" class="text-sm text-gray-600">モジュールを選択してください</div>
        </div>
    </div>

<script>
    // グローバル変数
    let audioContext;
    let modules = [];
    let connections = [];
    let nextModuleId = 0;
    let selectedModule = null;
    let draggingModule = null;
    let dragOffsetX, dragOffsetY;
    let drawingLine = null;
    let lineStartNodeInfo = null;
    let isAudioStarted = false;
    let globalOutputNode = null;
    const correctAnswer = { // ★ 新しい構造で初期化
        modulesConfig: [] // 例: [{type: 'oscillator', params: {...}}, {type: 'filter', params: {...}}, {type: 'gain', params: {...}}]
    };

    const workspace = document.getElementById('workspace');
    const connectionsSvg = document.getElementById('connections-svg');
    const modulePalette = document.getElementById('module-palette');
    const paramEditorContent = document.getElementById('editor-content');
    const startAudioButton = document.getElementById('start-audio-button');
    const playButton = document.getElementById('play-button');
    const stopButton = document.getElementById('stop-button');
    const resetButton = document.getElementById('reset-button');

    // --- オーディオコンテキストの初期化 ---
    startAudioButton.addEventListener('click', () => {
        if (!audioContext) {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            console.log('AudioContext created.');
        }
        if (audioContext.state === 'suspended') {
            audioContext.resume().then(() => {
                console.log('AudioContext resumed.');
                if (globalOutputNode && !globalOutputNode.audioNode) {
                    globalOutputNode.initAudioNode(); // OutputModuleのaudioNodeを再初期化
                }
            });
        }
        isAudioStarted = true;
        startAudioButton.disabled = true;
        startAudioButton.textContent = 'オーディオ動作中';
        startAudioButton.classList.remove('control-button-green');
        startAudioButton.classList.add('control-button-gray');
        playButton.disabled = false;
        stopButton.disabled = false;
    });

    // --- モジュール基底クラス ---
    class AudioModule {
        constructor(type, x, y, namePrefix = '') {
            this.id = nextModuleId++;
            this.type = type;
            this.name = `${namePrefix}${type.charAt(0).toUpperCase() + type.slice(1)} #${this.id}`;
            this.audioNode = null;
            this.connections = [];

            this.domElement = document.createElement('div');
            this.domElement.className = 'module';
            this.domElement.id = `module-${this.id}`;
            this.domElement.style.left = `${x}px`;
            this.domElement.style.top = `${y}px`;
            
            const title = document.createElement('div');
            title.className = 'module-title';
            title.textContent = this.name;
            this.domElement.appendChild(title);

            this.paramContainer = document.createElement('div');
            this.domElement.appendChild(this.paramContainer);

            this.domElement.addEventListener('mousedown', (e) => {
                if (e.target.classList.contains('io-node')) return;
                draggingModule = this;
                const rect = this.domElement.getBoundingClientRect();
                dragOffsetX = e.clientX - rect.left;
                dragOffsetY = e.clientY - rect.top;
                this.domElement.style.cursor = 'grabbing';
                this.domElement.style.zIndex = 1000;
            });
            
            this.domElement.addEventListener('click', (e) => {
                if (e.target.classList.contains('io-node')) return;
                selectModule(this);
            });

            this.createInputNodeDOM();
            this.createOutputNodeDOM();
            
            workspace.appendChild(this.domElement);
            modules.push(this);
        }

        initAudioNode() { /* 各サブクラスで実装 */ }
        getEditorHTML() { return ''; }
        updateParams() { /* 各サブクラスで実装 */ }

        createInputNodeDOM() {
            if (this.type === 'oscillator' || this.type === 'output') return;
            const inputNodeDOM = document.createElement('div');
            inputNodeDOM.className = 'io-node input-node';
            inputNodeDOM.dataset.moduleId = this.id;
            inputNodeDOM.dataset.nodeType = 'input';
            this.domElement.appendChild(inputNodeDOM);

            inputNodeDOM.addEventListener('mousedown', (e) => e.stopPropagation());
            inputNodeDOM.addEventListener('mouseup', (e) => {
                if (drawingLine && lineStartNodeInfo && lineStartNodeInfo.type === 'output') {
                    connectModules(lineStartNodeInfo.moduleId, this.id, lineStartNodeInfo.nodeElement, inputNodeDOM);
                }
                stopDrawingLine();
            });
        }

        createOutputNodeDOM() {
            if (this.type === 'output') return;
            const outputNodeDOM = document.createElement('div');
            outputNodeDOM.className = 'io-node output-node';
            outputNodeDOM.dataset.moduleId = this.id;
            outputNodeDOM.dataset.nodeType = 'output';
            this.domElement.appendChild(outputNodeDOM);
            
            outputNodeDOM.addEventListener('mousedown', (e) => {
                e.stopPropagation();
                startDrawingLine(this.id, outputNodeDOM, e);
            });
        }
        
        connectTo(targetModule) {
            if (!audioContext || !this.audioNode) {
                console.error(`${this.name}: AudioContext or source audioNode not available.`);
                return false;
            }
            if (targetModule.type === 'output') {
                if (audioContext.destination) {
                    try {
                        this.audioNode.connect(audioContext.destination);
                        console.log(`SUCCESS: Connected ${this.name} to Master Output (audioContext.destination)`);
                        return true;
                    } catch (e) {
                        console.error(`ERROR: Connecting ${this.name} to Master Output:`, e);
                        return false;
                    }
                } else {
                    console.error(`${this.name}: audioContext.destination is not available.`);
                    return false;
                }
            } else if (targetModule.audioNode instanceof AudioNode) {
                try {
                    this.audioNode.connect(targetModule.audioNode);
                    console.log(`SUCCESS: Connected ${this.name} to ${targetModule.name}`);
                    return true;
                } catch (e) {
                    console.error(`ERROR: Connecting ${this.name} to ${targetModule.name}:`, e);
                    return false;
                }
            } else {
                console.error(`${this.name}: Target module ${targetModule.name} (${targetModule.type}) has no valid audioNode or is not an Output.`);
                return false;
            }
        }
        
        disconnectFrom(targetModule) {
            if (!this.audioNode) return;
            try {
                 if (this.audioNode.disconnect && typeof this.audioNode.disconnect === 'function') {
                    if (targetModule.type === 'output' && audioContext && audioContext.destination) {
                        this.audioNode.disconnect(audioContext.destination);
                    } else if (targetModule.audioNode instanceof AudioNode) {
                        this.audioNode.disconnect(targetModule.audioNode);
                    }
                    // console.log(`Disconnected ${this.name} from ${targetModule.name}`);
                }
            } catch (error) {
                // console.warn(`Warning disconnecting ${this.name} from ${targetModule.name}:`, error);
            }
        }
        
        destroy() {
            // このモジュールからの出力接続をまず解除
            this.connections.forEach(connInfo => {
                const target = modules.find(m => m.id === connInfo.targetId);
                if (target) this.disconnectFrom(target);
            });
            // このモジュールへの入力接続を、ソース側から解除
            connections.filter(c => c.targetId === this.id).forEach(connToThis => {
                const source = modules.find(m => m.id === connToThis.sourceId);
                if (source) source.disconnectFrom(this);
            });

            connections = connections.filter(c => c.sourceId !== this.id && c.targetId !== this.id);
            
            if (this.audioNode) {
                if (this.type === 'oscillator' && this.audioNode.stop) {
                    try { if(this.isPlaying) this.audioNode.stop(); } catch (e) {}
                }
                try { this.audioNode.disconnect(); } catch (e) {} // 全ての接続を解除
            }

            if (this.domElement.parentElement) {
                this.domElement.parentElement.removeChild(this.domElement);
            }
            modules = modules.filter(m => m.id !== this.id);
            if (selectedModule === this) {
                selectedModule = null;
                clearParamEditor();
            }
            updateConnectionsSVG();
        }
    }

    // --- 各モジュールクラス ---
    class OscillatorModule extends AudioModule {
        constructor(x, y) {
            super('oscillator', x, y, 'Osc ');
            this.params = { type: 'sine', frequency: 440, detune: 0 };
            this.isPlaying = false;
            this.initAudioNode();
            this.updateParams();
        }
        initAudioNode() {
            if (!audioContext) return;
            if (this.audioNode) {
                try { if(this.isPlaying) this.audioNode.stop(); } catch(e) {}
                try { this.audioNode.disconnect(); } catch(e) {}
            }
            this.audioNode = audioContext.createOscillator();
            this.audioNode.type = this.params.type;
            this.audioNode.frequency.setValueAtTime(this.params.frequency, audioContext.currentTime);
            this.audioNode.detune.setValueAtTime(this.params.detune, audioContext.currentTime);
        }
        getEditorHTML() {
            return `
                <div class="mb-2">
                    <label class="param-label">Type:
                        <select id="osc-type-${this.id}" class="custom-select">
                            <option value="sine" ${this.params.type === 'sine' ? 'selected' : ''}>Sine</option>
                            <option value="square" ${this.params.type === 'square' ? 'selected' : ''}>Square</option>
                            <option value="sawtooth" ${this.params.type === 'sawtooth' ? 'selected' : ''}>Sawtooth</option>
                            <option value="triangle" ${this.params.type === 'triangle' ? 'selected' : ''}>Triangle</option>
                        </select>
                    </label>
                </div>
                <div class="mb-2">
                    <label class="param-label">Frequency: <span id="freq-val-${this.id}">${this.params.frequency}</span> Hz
                        <input type="range" id="osc-freq-${this.id}" class="param-slider" min="20" max="2000" step="1" value="${this.params.frequency}">
                    </label>
                </div>
                 <div class="mb-2">
                    <label class="param-label">Detune: <span id="detune-val-${this.id}">${this.params.detune}</span> Cents
                        <input type="range" id="osc-detune-${this.id}" class="param-slider" min="-1200" max="1200" step="1" value="${this.params.detune}">
                    </label>
                </div>
            `;
        }
        updateParams() { // initAudioNode を呼ぶ方が確実な場合が多い
            if (!this.audioNode || !audioContext) return;
            this.audioNode.type = this.params.type;
            this.audioNode.frequency.value = this.params.frequency; // 即時変更
            this.audioNode.detune.value = this.params.detune;       // 即時変更
        }
    }

    class GainModule extends AudioModule {
        constructor(x, y) {
            super('gain', x, y, 'Gain ');
            this.params = { gain: 0.5 };
            this.initAudioNode();
            this.updateParams();
        }
        initAudioNode() {
            if (!audioContext) return;
            if (this.audioNode) { try { this.audioNode.disconnect(); } catch(e) {} }
            this.audioNode = audioContext.createGain();
            this.audioNode.gain.setValueAtTime(this.params.gain, audioContext.currentTime);
        }
        getEditorHTML() {
            return `
                <div class="mb-2">
                    <label class="param-label">Gain: <span id="gain-val-${this.id}">${this.params.gain.toFixed(2)}</span>
                        <input type="range" id="gain-amount-${this.id}" class="param-slider" min="0" max="1" step="0.01" value="${this.params.gain}">
                    </label>
                </div>
            `;
        }
        updateParams() {
            if (!this.audioNode || !audioContext) return;
            this.audioNode.gain.value = this.params.gain; // 即時変更
        }
    }
    
    class FilterModule extends AudioModule {
        constructor(x, y) {
            super('filter', x, y, 'Filter ');
            this.params = { type: 'lowpass', frequency: 350, q: 1 };
            this.initAudioNode();
            this.updateParams();
        }
        initAudioNode() {
            if (!audioContext) return;
            if (this.audioNode) { try { this.audioNode.disconnect(); } catch(e) {} }
            this.audioNode = audioContext.createBiquadFilter();
            this.audioNode.type = this.params.type; 
            this.audioNode.frequency.setValueAtTime(this.params.frequency, audioContext.currentTime);
            this.audioNode.Q.setValueAtTime(this.params.q, audioContext.currentTime);
        }
        getEditorHTML() {
            return `
                <div class="mb-2">
                    <label class="param-label">Type:
                        <select id="filter-type-${this.id}" class="custom-select">
                            <option value="lowpass" ${this.params.type === 'lowpass' ? 'selected' : ''}>Lowpass</option>
                            <option value="highpass" ${this.params.type === 'highpass' ? 'selected' : ''}>Highpass</option>
                            <option value="bandpass" ${this.params.type === 'bandpass' ? 'selected' : ''}>Bandpass</option>
                            <option value="lowshelf" ${this.params.type === 'lowshelf' ? 'selected' : ''}>Lowshelf</option>
                            <option value="highshelf" ${this.params.type === 'highshelf' ? 'selected' : ''}>Highshelf</option>
                            <option value="peaking" ${this.params.type === 'peaking' ? 'selected' : ''}>Peaking</option>
                            <option value="notch" ${this.params.type === 'notch' ? 'selected' : ''}>Notch</option>
                            <option value="allpass" ${this.params.type === 'allpass' ? 'selected' : ''}>Allpass</option>
                        </select>
                    </label>
                </div>
                <div class="mb-2">
                    <label class="param-label">Frequency: <span id="filter-freq-val-${this.id}">${this.params.frequency}</span> Hz
                        <input type="range" id="filter-freq-${this.id}" class="param-slider" min="20" max="10000" step="1" value="${this.params.frequency}">
                    </label>
                </div>
                <div class="mb-2">
                    <label class="param-label">Q: <span id="filter-q-val-${this.id}">${this.params.q.toFixed(2)}</span>
                        <input type="range" id="filter-q-${this.id}" class="param-slider" min="0.0001" max="20" step="0.01" value="${this.params.q}">
                    </label>
                </div>
            `;
        }
        updateParams() {
            if (!this.audioNode || !audioContext) return;
            this.audioNode.type = this.params.type;
            this.audioNode.frequency.value = this.params.frequency; // 即時変更
            this.audioNode.Q.value = this.params.q;                 // 即時変更
        }
    }

    class DelayModule extends AudioModule {
        constructor(x,y) {
            super('delay', x, y, 'Delay ');
            this.params = { delayTime: 0.3, feedback: 0.4 };
            this.feedbackNode = null;
            this.initAudioNode();
            this.updateParams();
        }
        initAudioNode() {
            if (!audioContext) return;
            if (this.audioNode) { // 古いノードとフィードバックを切断
                try { this.audioNode.disconnect(); } catch(e) {}
                if(this.feedbackNode) { try { this.feedbackNode.disconnect(); } catch(e) {} }
            }
            this.audioNode = audioContext.createDelay(5.0); 
            this.feedbackNode = audioContext.createGain();
            
            this.audioNode.connect(this.feedbackNode);
            this.feedbackNode.connect(this.audioNode); 

            this.audioNode.delayTime.setValueAtTime(this.params.delayTime, audioContext.currentTime);
            this.feedbackNode.gain.setValueAtTime(this.params.feedback, audioContext.currentTime);
        }
        getEditorHTML() {
             return `
                <div class="mb-2">
                    <label class="param-label">Delay Time: <span id="delay-time-val-${this.id}">${this.params.delayTime.toFixed(2)}</span> s
                        <input type="range" id="delay-time-${this.id}" class="param-slider" min="0" max="2" step="0.01" value="${this.params.delayTime}">
                    </label>
                </div>
                 <div class="mb-2">
                    <label class="param-label">Feedback: <span id="delay-feedback-val-${this.id}">${this.params.feedback.toFixed(2)}</span>
                        <input type="range" id="delay-feedback-${this.id}" class="param-slider" min="0" max="0.95" step="0.01" value="${this.params.feedback}">
                    </label>
                </div>
            `;
        }
        updateParams() {
            if (!this.audioNode || !this.feedbackNode || !audioContext) return;
            this.audioNode.delayTime.value = this.params.delayTime; // 即時変更
            this.feedbackNode.gain.value = this.params.feedback;   // 即時変更
        }
        connectTo(targetModule) {
            if (!this.audioNode) return false; // audioNodeはDelayNode自体
            // ディレイの出力はDelayNodeから直接
            return super.connectTo(targetModule); // 基底クラスのconnectToを呼ぶ
        }
        connectInput(sourceModuleAudioNode) {
            if (!this.audioNode || !sourceModuleAudioNode) return false;
             try {
                sourceModuleAudioNode.connect(this.audioNode); // 入力はDelayNodeへ
                console.log(`SUCCESS: Connected input from ${sourceModuleAudioNode.constructor.name} to Delay ${this.name}`);
                return true;
            } catch (error) {
                console.error(`ERROR: Connecting input to Delay ${this.name}:`, error);
            }
            return false;
        }
        // disconnectFrom は基底クラスのものを使用
        disconnectInput(sourceModuleAudioNode) {
            if (!this.audioNode || !sourceModuleAudioNode) return;
            try {
                sourceModuleAudioNode.disconnect(this.audioNode);
            } catch(e) {}
        }
    }

    class OutputModule extends AudioModule {
        constructor(x,y) {
            super('output', x, y, 'Out ');
            this.initAudioNode(); // audioContextの準備ができていなくても呼ばれるが、initAudioNode内で対応
            if (globalOutputNode) {
                globalOutputNode.destroy();
            }
            globalOutputNode = this;
            this.createInputNodeDOM(); // 入力ノードを作成
        }

        initAudioNode() {
            if (!audioContext) {
                console.warn("AudioContext is not ready. OutputModule will wait for initialization.");
                return;
            }
            this.audioNode = audioContext.destination;
            console.log("Output module audioNode set to audioContext.destination");
        }

        createInputNodeDOM() {
            const inputNodeDOM = document.createElement('div');
            inputNodeDOM.className = 'io-node input-node';
            inputNodeDOM.dataset.moduleId = this.id;
            inputNodeDOM.dataset.nodeType = 'input';
            this.domElement.appendChild(inputNodeDOM);

            inputNodeDOM.addEventListener('mousedown', (e) => e.stopPropagation());
            inputNodeDOM.addEventListener('mouseup', (e) => {
                if (drawingLine && lineStartNodeInfo && lineStartNodeInfo.type === 'output') {
                    connectModules(lineStartNodeInfo.moduleId, this.id, lineStartNodeInfo.nodeElement, inputNodeDOM);
                }
                stopDrawingLine();
            });
        }

        getEditorHTML() {
            return `<p class="text-xs text-gray-500">マスター出力。他のモジュールの出力をここに接続してください。</p>`;
        }
    }
    
    // --- モジュール作成・選択 ---
    modulePalette.addEventListener('click', (e) => {
        if (e.target.tagName === 'BUTTON') {
            const type = e.target.dataset.type;
            if (!isAudioStarted && type !== 'output') {
                alert('まず「オーディオ開始」ボタンを押してください。');
                return;
            }
            createModule(type, 50, 50);
        }
    });

    function createModule(type, x, y) {
        let newModule;
        switch (type) {
            case 'oscillator': newModule = new OscillatorModule(x, y); break;
            case 'gain': newModule = new GainModule(x, y); break;
            case 'filter': newModule = new FilterModule(x, y); break;
            case 'delay': newModule = new DelayModule(x, y); break;
            case 'output': newModule = new OutputModule(x, y); break;
            default: return;
        }
        selectModule(newModule);
        return newModule;
    }
    
    function selectModule(module) {
        if (selectedModule && selectedModule.domElement) {
            selectedModule.domElement.style.borderColor = '#ccc';
        }
        selectedModule = module;
        if (selectedModule && selectedModule.domElement) {
            selectedModule.domElement.style.borderColor = '#3498db';
            renderParamEditor(module);
        } else {
            clearParamEditor();
        }
    }

    function clearParamEditor() {
        paramEditorContent.innerHTML = '<p class="text-sm text-gray-500">モジュールを選択してください</p>';
    }
    
    function renderParamEditor(module) {
        paramEditorContent.innerHTML = '';
        const title = document.createElement('h3');
        title.textContent = module.name;
        title.className = 'text-md font-semibold mb-2 text-slate-600';
        paramEditorContent.appendChild(title);

        const editorHTML = module.getEditorHTML();
        paramEditorContent.innerHTML += editorHTML;

        if (module.type === 'oscillator') {
            document.getElementById(`osc-type-${module.id}`).addEventListener('change', (e) => {
                module.params.type = e.target.value;
                module.initAudioNode(); 
                reconnectModule(module);
            });
            document.getElementById(`osc-freq-${module.id}`).addEventListener('input', (e) => {
                module.params.frequency = parseFloat(e.target.value);
                document.getElementById(`freq-val-${module.id}`).textContent = module.params.frequency;
                if (module.audioNode && audioContext) module.audioNode.frequency.setValueAtTime(module.params.frequency, audioContext.currentTime);
            });
            document.getElementById(`osc-detune-${module.id}`).addEventListener('input', (e) => {
                module.params.detune = parseFloat(e.target.value);
                document.getElementById(`detune-val-${module.id}`).textContent = module.params.detune;
                 if (module.audioNode && audioContext) module.audioNode.detune.setValueAtTime(module.params.detune, audioContext.currentTime);
            });
        } else if (module.type === 'gain') {
             document.getElementById(`gain-amount-${module.id}`).addEventListener('input', (e) => {
                module.params.gain = parseFloat(e.target.value);
                document.getElementById(`gain-val-${module.id}`).textContent = module.params.gain.toFixed(2);
                module.updateParams();
            });
        } else if (module.type === 'filter') {
            document.getElementById(`filter-type-${module.id}`).addEventListener('change', (e) => {
                module.params.type = e.target.value;
                module.updateParams(); // タイプ変更はupdateParamsで対応
            });
            document.getElementById(`filter-freq-${module.id}`).addEventListener('input', (e) => {
                module.params.frequency = parseFloat(e.target.value);
                 document.getElementById(`filter-freq-val-${module.id}`).textContent = module.params.frequency;
                module.updateParams();
            });
            document.getElementById(`filter-q-${module.id}`).addEventListener('input', (e) => {
                module.params.q = parseFloat(e.target.value);
                document.getElementById(`filter-q-val-${module.id}`).textContent = module.params.q.toFixed(2);
                module.updateParams();
            });
        } else if (module.type === 'delay') {
            document.getElementById(`delay-time-${module.id}`).addEventListener('input', (e) => {
                module.params.delayTime = parseFloat(e.target.value);
                document.getElementById(`delay-time-val-${module.id}`).textContent = module.params.delayTime.toFixed(2);
                module.updateParams();
            });
             document.getElementById(`delay-feedback-${module.id}`).addEventListener('input', (e) => {
                module.params.feedback = parseFloat(e.target.value);
                document.getElementById(`delay-feedback-val-${module.id}`).textContent = module.params.feedback.toFixed(2);
                module.updateParams();
            });
        }
        
        const deleteButton = document.createElement('button');
        deleteButton.textContent = 'モジュール削除';
        deleteButton.className = 'control-button control-button-red mt-4 w-full text-sm';
        deleteButton.onclick = () => {
            if (confirm(`${module.name} を削除しますか？`)) {
                module.destroy();
            }
        };
        paramEditorContent.appendChild(deleteButton);
    }

    // --- ドラッグ＆ドロップ処理 ---
    document.addEventListener('mousemove', (e) => {
        if (draggingModule) {
            const workspaceRect = workspace.getBoundingClientRect();
            let newX = e.clientX - workspaceRect.left - dragOffsetX;
            let newY = e.clientY - workspaceRect.top - dragOffsetY;
            
            newX = Math.max(0, Math.min(newX, workspace.offsetWidth - draggingModule.domElement.offsetWidth));
            newY = Math.max(0, Math.min(newY, workspace.offsetHeight - draggingModule.domElement.offsetHeight));

            draggingModule.domElement.style.left = `${newX}px`;
            draggingModule.domElement.style.top = `${newY}px`;
            updateConnectionsSVG();
        }
        if (drawingLine && lineStartNodeInfo) {
            const workspaceRect = workspace.getBoundingClientRect();
            drawingLine.setAttribute('x2', e.clientX - workspaceRect.left);
            drawingLine.setAttribute('y2', e.clientY - workspaceRect.top);
        }
    });

    document.addEventListener('mouseup', () => {
        if (draggingModule) {
            draggingModule.domElement.style.cursor = 'grabbing';
            draggingModule.domElement.style.zIndex = 1;
            draggingModule = null;
        }
        stopDrawingLine();
    });
    
    // --- 接続描画処理 ---
    function startDrawingLine(moduleId, nodeElement, event) {
        if (drawingLine && drawingLine.parentElement) connectionsSvg.removeChild(drawingLine);

        drawingLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        drawingLine.classList.add('connection-line');
        drawingLine.style.pointerEvents = 'none';

        const workspaceRect = workspace.getBoundingClientRect();
        const nodeRect = nodeElement.getBoundingClientRect();
        
        const startX = nodeRect.left - workspaceRect.left + nodeRect.width / 2;
        const startY = nodeRect.top - workspaceRect.top + nodeRect.height / 2;

        drawingLine.setAttribute('x1', startX);
        drawingLine.setAttribute('y1', startY);
        drawingLine.setAttribute('x2', startX);
        drawingLine.setAttribute('y2', startY);
        
        connectionsSvg.appendChild(drawingLine);
        lineStartNodeInfo = { moduleId: parseInt(nodeElement.dataset.moduleId), type: nodeElement.dataset.nodeType, nodeElement: nodeElement };
    }

    function stopDrawingLine() {
        if (drawingLine) {
            if (drawingLine.parentElement === connectionsSvg) {
                 connectionsSvg.removeChild(drawingLine);
            }
            drawingLine = null;
        }
        lineStartNodeInfo = null;
    }
    
    function connectModules(sourceModuleId, targetModuleId, sourceNodeDOM, targetNodeDOM) {
        const sourceModule = modules.find(m => m.id === sourceModuleId);
        const targetModule = modules.find(m => m.id === targetModuleId);

        if (sourceModule && targetModule && sourceModuleId !== targetModuleId) {
            const existingConnection = connections.find(
                c => c.sourceId === sourceModuleId && c.targetId === targetModuleId
            );
            if (existingConnection) {
                console.log("Connection already exists.");
                return;
            }
            
            let success = false;
            if (targetModule.type === 'output') {
                // OutputModuleへの接続
                if (audioContext && audioContext.destination) {
                    try {
                        sourceModule.audioNode.connect(audioContext.destination);
                        success = true;
                    } catch (e) {
                        console.error(`Failed to connect ${sourceModule.name} to OutputModule:`, e);
                    }
                }
            } else if (targetModule.type === 'delay' && typeof targetModule.connectInput === 'function') {
                success = targetModule.connectInput(sourceModule.audioNode);
            } else {
                success = sourceModule.connectTo(targetModule);
            }

            if (success) {
                const newConnection = {
                    id: `conn-${sourceModuleId}-${targetModuleId}`,
                    sourceId: sourceModuleId,
                    targetId: targetModuleId,
                    sourceNodeDOM: sourceNodeDOM,
                    targetNodeDOM: targetNodeDOM
                };
                connections.push(newConnection);
                sourceModule.connections.push({ targetId: targetModuleId, type: 'output' });
                updateConnectionsSVG();
            } else {
                console.warn(`Failed to connect ${sourceModule.name} to ${targetModule.name}.`);
            }
        }
    }
    
    // --- エッジのダブルクリック削除機能を修正 ---
    function updateConnectionsSVG() {
        connectionsSvg.innerHTML = '';
        const validConnections = [];
        connections.forEach(conn => {
            const sourceModule = modules.find(m => m.id === conn.sourceId);
            const targetModule = modules.find(m => m.id === conn.targetId);

            if (sourceModule && targetModule && 
                document.body.contains(conn.sourceNodeDOM) && 
                document.body.contains(conn.targetNodeDOM)) {
                
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.classList.add('connection-line');
                line.dataset.connId = conn.id;

                const workspaceRect = workspace.getBoundingClientRect();
                
                const sourceRect = conn.sourceNodeDOM.getBoundingClientRect();
                const targetRect = conn.targetNodeDOM.getBoundingClientRect();

                const x1 = sourceRect.left - workspaceRect.left + sourceRect.width / 2;
                const y1 = sourceRect.top - workspaceRect.top + sourceRect.height / 2;
                const x2 = targetRect.left - workspaceRect.left + targetRect.width / 2;
                const y2 = targetRect.top - workspaceRect.top + targetRect.height / 2;

                line.setAttribute('x1', x1);
                line.setAttribute('y1', y1);
                line.setAttribute('x2', x2);
                line.setAttribute('y2', y2);
                
                line.addEventListener('dblclick', (e) => {
                    disconnectById(conn.id);
                });
                connectionsSvg.appendChild(line);
                validConnections.push(conn); // 有効な接続のみを保持
            }
        });
        connections = validConnections; // 無効な接続を配列から削除
    }

    // --- 正解をランダムに生成 ---
    function generateRandomCorrectAnswer() {
        correctAnswer.modulesConfig = []; // 毎回クリア
        const moduleOrder = [];

        // 1. Oscillatorは必須
        moduleOrder.push('oscillator');

        // 2. Filter を確率で追加 (70%の確率)
        if (Math.random() < 0.7) {
            moduleOrder.push('filter');
        }

        // 3. Delay を確率で追加 (70%の確率)
        if (Math.random() < 0.7) {
            moduleOrder.push('delay');
        }

        // 4. Gainは必須 (最後に配置)
        moduleOrder.push('gain');

        moduleOrder.forEach(type => {
            let params = {};
            switch (type) {
                case 'oscillator':
                    const oscTypes = ['sine', 'square', 'sawtooth', 'triangle'];
                    params = {
                        type: oscTypes[Math.floor(Math.random() * oscTypes.length)],
                        frequency: Math.floor(Math.random() * (1200 - 80 + 1)) + 80, // 80Hz〜1200Hz
                        detune: Math.floor(Math.random() * (100 - (-100) + 1)) + (-100) // -100〜100 Cents
                    };
                    break;
                case 'gain':
                    params = {
                        gain: parseFloat((Math.random() * (0.8 - 0.1) + 0.1).toFixed(2)) // 0.1〜0.8
                    };
                    break;
                case 'filter':
                    const filterTypes = ['lowpass', 'highpass', 'bandpass', 'notch', 'peaking'];
                    params = {
                        type: filterTypes[Math.floor(Math.random() * filterTypes.length)],
                        frequency: Math.floor(Math.random() * (7000 - 150 + 1)) + 150, // 150Hz〜7000Hz
                        q: parseFloat((Math.random() * (10 - 0.2) + 0.2).toFixed(2)) // 0.2〜10
                    };
                    break;
                case 'delay':
                    params = {
                        delayTime: parseFloat((Math.random() * (0.9 - 0.05) + 0.05).toFixed(3)), // 0.05s〜0.9s
                        feedback: parseFloat((Math.random() * (0.75 - 0.05) + 0.05).toFixed(2)) // 0.05〜0.75
                    };
                    break;
            }
            correctAnswer.modulesConfig.push({ type: type, params: params });
        });

        console.log('新しい正解 (modulesConfig):', JSON.parse(JSON.stringify(correctAnswer.modulesConfig)));
        // 注意: playCorrectAnswer と checkAnswer 関数もこの新しい correctAnswer.modulesConfig 構造に
        // 合わせて修正する必要があります。
    }

    // // --- 答え合わせフェーズの修正 ---
    // function checkAnswer() {
    //     let score = 0;
    //     let explanation = '';
    //     let usedModules = 0;

    //     const userOscillator = modules.find(m => m.type === 'oscillator');
    //     const userGain = modules.find(m => m.type === 'gain');

    //     if (userOscillator) {
    //         usedModules++;
    //         if (userOscillator.params.type === correctAnswer.params.type) {
    //             score += 40;
    //         } else {
    //             explanation += `オシレーターのタイプが異なります。正解: ${correctAnswer.params.type}\n`;
    //         }
    //         if (Math.abs(userOscillator.params.frequency - correctAnswer.params.frequency) <= 5) {
    //             score += 30;
    //         } else {
    //             explanation += `周波数が異なります。正解: ${correctAnswer.params.frequency}Hz\n`;
    //         }
    //     } else {
    //         explanation += 'オシレーターモジュールがありません。\n';
    //     }

    //     if (userGain) {
    //         usedModules++;
    //         if (Math.abs(userGain.params.gain - correctAnswer.params.gain) <= 0.05) {
    //             score += 30;
    //         } else {
    //             explanation += `ゲインが異なります。正解: ${correctAnswer.params.gain}\n`;
    //         }
    //     } else {
    //         explanation += 'ゲインモジュールがありません。\n';
    //     }

    //     alert(`スコア: ${score}/100\n${explanation}\n使用したモジュール数: ${usedModules}`);
    //     displayCorrectAnswerDetails();
    // }

    // --- 出力モジュールボタンを削除 ---
    // document.querySelector('button[data-type="output"]').remove();

    // --- 正解の発表で接続図と設定値を表示 ---
    function displayCorrectAnswerDetails() {
        const detailsContainer = document.createElement('div');
        detailsContainer.className = 'correct-answer-details';

        const title = document.createElement('h3');
        title.textContent = '正解の詳細';
        title.className = 'text-lg font-semibold mb-2 text-slate-600';
        detailsContainer.appendChild(title);

        const connectionsList = document.createElement('ul');
        connectionsList.className = 'text-sm text-gray-600';

        const oscillatorDetails = `オシレーター: タイプ=${correctAnswer.params.type}, 周波数=${correctAnswer.params.frequency}Hz`;
        const gainDetails = `ゲイン: 値=${correctAnswer.params.gain}`;

        const oscillatorItem = document.createElement('li');
        oscillatorItem.textContent = oscillatorDetails;
        connectionsList.appendChild(oscillatorItem);

        const gainItem = document.createElement('li');
        gainItem.textContent = gainDetails;
        connectionsList.appendChild(gainItem);

        detailsContainer.appendChild(connectionsList);

        const workspace = document.getElementById('workspace');
        workspace.appendChild(detailsContainer);
    }

    // --- グローバルコントロール ---
    playButton.addEventListener('click', () => {
        if (!isAudioStarted || !audioContext) return;
        if (audioContext.state === 'suspended') {
            audioContext.resume().then(() => {
                console.log("AudioContext resumed by play button.");
                startOscillatorsAndReconnect();
            });
        } else {
            startOscillatorsAndReconnect();
        }
    });

    function startOscillatorsAndReconnect() {
        console.log("Starting oscillators and reconnecting...");
        modules.forEach(module => {
            if (module.type === 'oscillator' && module.audioNode && typeof module.audioNode.start === 'function') {
                if (!module.isPlaying) { 
                    module.initAudioNode(); 
                    module.audioNode.start(0);
                    module.isPlaying = true; 
                    console.log(`Oscillator ${module.name} started.`);
                }
            }
        });
        reconnectAll();
        console.log("Playback attempted.");
    }


    stopButton.addEventListener('click', () => {
        if (!isAudioStarted || !audioContext) return;
        console.log("Stopping oscillators...");
        modules.forEach(module => {
            if (module.type === 'oscillator' && module.audioNode && typeof module.audioNode.stop === 'function') {
                 try {
                    if (module.isPlaying) {
                        module.audioNode.stop(0);
                        module.isPlaying = false;
                        console.log(`Oscillator ${module.name} stopped.`);
                    }
                } catch (e) { 
                    console.warn(`Error stopping oscillator ${module.name}:`, e);
                }
            }
        });
        modules.filter(m => m.type === 'oscillator').forEach(osc => {
            osc.initAudioNode(); 
        });
        reconnectAll();
        console.log("Playback stopped, oscillators re-initialized.");
    });

    resetButton.addEventListener('click', () => {
        if (confirm('すべてのモジュールと接続をリセットしますか？')) {
            stopButton.click(); 

            [...modules].reverse().forEach(m => m.destroy());
            
            modules = [];
            connections = [];
            nextModuleId = 0;
            selectedModule = null;
            draggingModule = null;
            if (globalOutputNode && globalOutputNode.type === 'output') { // Outputが残っていたらnull化
                // globalOutputNode.destroy()は上のループで呼ばれる
            }
            globalOutputNode = null; 
            
            clearParamEditor();
            connectionsSvg.innerHTML = ''; // SVGもクリア
            console.log("Workspace reset.");
        }
    });

    function reconnectAll() {
        console.log("Reconnecting all modules...");
        // 既存のWeb Audio API接続を全て解除
        modules.forEach(sourceModule => {
            if (sourceModule.audioNode && typeof sourceModule.audioNode.disconnect === 'function') {
                try { sourceModule.audioNode.disconnect(); } catch(e) {}
            }
            if (sourceModule.type === 'delay' && sourceModule.feedbackNode && sourceModule.audioNode) {
                 try { 
                    sourceModule.feedbackNode.disconnect(); // フィードバックループも切断
                    // 再接続はinitAudioNodeで行われるか、ここで行う
                    sourceModule.audioNode.connect(sourceModule.feedbackNode);
                    sourceModule.feedbackNode.connect(sourceModule.audioNode);
                } catch(e) {}
            }
        });
    
        // connections配列に基づいてWeb Audio API接続を再構築
        connections.forEach(conn => {
            const sourceModule = modules.find(m => m.id === conn.sourceId);
            const targetModule = modules.find(m => m.id === conn.targetId);
            if (sourceModule && targetModule && sourceModule.audioNode) {
                console.log(`Attempting to reconnect ${sourceModule.name} to ${targetModule.name}`);
                let success = false;
                if (targetModule.type === 'delay' && typeof targetModule.connectInput === 'function') {
                    success = targetModule.connectInput(sourceModule.audioNode);
                } else { // OutputModuleもこちらで処理される (connectTo内で分岐)
                    success = sourceModule.connectTo(targetModule);
                }
                if(!success) console.warn(`Failed to reconnect ${sourceModule.name} to ${targetModule.name} during reconnectAll.`);
            } else {
                console.warn(`Could not reconnect: source or target module or source.audioNode missing for conn id ${conn.id}`);
            }
        });
        console.log("reconnectAll finished.");
    }

    function reconnectModule(moduleToReconnect) { // 主にオシレータータイプ変更時など、単体モジュールのAudioNodeが再生成された時
        console.log(`Reconnecting module: ${moduleToReconnect.name}`);
        // このモジュールからの出力接続を再接続
        connections.filter(conn => conn.sourceId === moduleToReconnect.id).forEach(conn => {
            const targetModule = modules.find(m => m.id === conn.targetId);
            if (targetModule && moduleToReconnect.audioNode) { // moduleToReconnect.audioNodeが新しいものであることを確認
                console.log(`  Re-establishing output from ${moduleToReconnect.name} to ${targetModule.name}`);
                // 古い接続を切る必要はない（AudioNodeごと変わるので）
                if (targetModule.type === 'delay' && typeof targetModule.connectInput === 'function') {
                    targetModule.connectInput(moduleToReconnect.audioNode);
                } else {
                    moduleToReconnect.connectTo(targetModule);
                }
            }
        });

        // このモジュールへの入力接続を再接続
        connections.filter(conn => conn.targetId === moduleToReconnect.id).forEach(conn => {
            const sourceModule = modules.find(m => m.id === conn.sourceId);
            if (sourceModule && sourceModule.audioNode) { // sourceModule.audioNodeが存在することを確認
                console.log(`  Re-establishing input from ${sourceModule.name} to ${moduleToReconnect.name}`);
                // 古い接続を切る
                sourceModule.disconnectFrom(moduleToReconnect); // moduleToReconnectは古いAudioNodeを参照している可能性がある
                // 新しいAudioNodeに再接続
                if (moduleToReconnect.type === 'delay' && typeof moduleToReconnect.connectInput === 'function') {
                    moduleToReconnect.connectInput(sourceModule.audioNode);
                } else {
                    sourceModule.connectTo(moduleToReconnect);
                }
            }
        });
        if(moduleToReconnect.type === 'delay' && moduleToReconnect.audioNode && moduleToReconnect.feedbackNode){
            try{
                moduleToReconnect.audioNode.disconnect(moduleToReconnect.feedbackNode);
                moduleToReconnect.feedbackNode.disconnect(moduleToReconnect.audioNode);
            } catch(e){}
            moduleToReconnect.audioNode.connect(moduleToReconnect.feedbackNode);
            moduleToReconnect.feedbackNode.connect(moduleToReconnect.audioNode);
        }
        console.log(`Finished reconnecting module: ${moduleToReconnect.name}`);
    }

    // 初期状態
    clearParamEditor();

    // --- 初期状態でOutputモジュールを配置 ---
    window.addEventListener('load', () => {
        if (!globalOutputNode) {
            const outputModule = new OutputModule(600, 200); // 盤面中央に配置
            workspace.appendChild(outputModule.domElement); // DOMに追加
            modules.push(outputModule); // モジュールリストに追加
            globalOutputNode = outputModule; // グローバル変数に設定
            console.log('Output module initialized and added to workspace.');
        }

        // 正解を初期化 -> generateRandomCorrectAnswerを呼び出す
        generateRandomCorrectAnswer();
        console.log('ランダムな正解が初期生成されました。');
    });

    // --- 正解音を提示する機能 ---
    // const correctAnswer = { // ★ この古い定義は削除 (グローバル変数セクションに新しい定義を移動済み)
    // type: 'oscillator',
    // params: {
    // type: 'sine',
    // frequency: 440,
    // gain: 0.5
    // }
    // };

    function playCorrectAnswer() {
        // TODO: この関数は新しい correctAnswer.modulesConfig を使用するように修正が必要です。
        // 現在の実装は古い correctAnswer.params を参照しているため、正しく動作しません。
        
        // 一時的なAudioNodeの配列
        let tempAudioNodes = [];
        let lastConnectedNode = null;

        if (!correctAnswer.modulesConfig || correctAnswer.modulesConfig.length === 0) {
            console.error("正解音の再生に必要なモジュール設定(correctAnswer.modulesConfig)がありません。");
            return;
        }

        try {
            correctAnswer.modulesConfig.forEach(moduleConfig => {
                let currentNode = null;
                switch (moduleConfig.type) {
                    case 'oscillator':
                        const osc = audioContext.createOscillator();
                        osc.type = moduleConfig.params.type;
                        osc.frequency.setValueAtTime(moduleConfig.params.frequency, audioContext.currentTime);
                        if (moduleConfig.params.detune !== undefined) {
                            osc.detune.setValueAtTime(moduleConfig.params.detune, audioContext.currentTime);
                        }
                        osc.start(audioContext.currentTime);
                        currentNode = osc;
                        break;
                    case 'filter':
                        const filter = audioContext.createBiquadFilter();
                        filter.type = moduleConfig.params.type;
                        filter.frequency.setValueAtTime(moduleConfig.params.frequency, audioContext.currentTime);
                        filter.Q.setValueAtTime(moduleConfig.params.q, audioContext.currentTime);
                        currentNode = filter;
                        break;
                    case 'delay':
                        const delay = audioContext.createDelay(5.0); // Max delay time
                        delay.delayTime.setValueAtTime(moduleConfig.params.delayTime, audioContext.currentTime);
                        
                        const feedback = audioContext.createGain();
                        feedback.gain.setValueAtTime(moduleConfig.params.feedback, audioContext.currentTime);
                        
                        delay.connect(feedback);
                        feedback.connect(delay); // Feedback loop
                        
                        currentNode = delay; 
                        // Delayの場合、入力はdelayノード、出力もdelayノードから。フィードバックは内部で完結。
                        // lastConnectedNode があれば、それを delay に接続する。
                        // delay の出力が次のノード、または destination に接続される。
                        break;
                    case 'gain':
                        const gainNode = audioContext.createGain();
                        gainNode.gain.setValueAtTime(moduleConfig.params.gain, audioContext.currentTime);
                        currentNode = gainNode;
                        break;
                }

                if (currentNode) {
                    if (lastConnectedNode) {
                        // Delayモジュールの場合、フィードバックゲインノードではなく、DelayNode自体に接続
                        if (lastConnectedNode.constructor.name === "DelayNode" && moduleConfig.type !== 'gain') {
                             // lastConnectedNodeがDelayNodeで、次に接続するのがGain以外（つまりDelayの出力先）の場合
                             // DelayNodeの出力をcurrentNodeに接続
                             lastConnectedNode.connect(currentNode);
                        } else if (lastConnectedNode.constructor.name === "GainNode" && tempAudioNodes.length > 1 && tempAudioNodes[tempAudioNodes.length-2].constructor.name === "DelayNode" && moduleConfig.type !== 'gain') {
                            // 前のノードがGainで、その前がDelayだった場合（Delayのフィードバックゲインの可能性）
                            // DelayNodeの出力をcurrentNodeに接続
                             const delayNodeForOutput = tempAudioNodes.find(n => n.node && n.node.constructor.name === "DelayNode" && n.type === 'delay');
                             if(delayNodeForOutput) delayNodeForOutput.node.connect(currentNode);
                             else lastConnectedNode.connect(currentNode); // フォールバック
                        }
                        else {
                            lastConnectedNode.connect(currentNode);
                        }
                    }
                    lastConnectedNode = currentNode;
                    tempAudioNodes.push({type: moduleConfig.type, node: currentNode});
                }
            });

            if (lastConnectedNode) {
                lastConnectedNode.connect(audioContext.destination);
            } else {
                 console.error("正解音の再生チェーンに有効なノードがありませんでした。");
                 return;
            }

            setTimeout(() => {
                tempAudioNodes.forEach(item => {
                    if (item.type === 'oscillator' && item.node.stop) {
                        try { item.node.stop(); } catch (e) {}
                    }
                    try { item.node.disconnect(); } catch (e) {}
                     // Delayの場合、feedbackNodeもdisconnect
                    if (item.type === 'delay') {
                        const fbNode = tempAudioNodes.find(n => n.type === 'feedbackGain' && n.originalDelayId === item.node.id); // 仮のid管理
                        if(fbNode) try { fbNode.node.disconnect(); } catch(e){}
                    }
                });
                tempAudioNodes = []; // クリア
            }, 2000); // 2秒間再生

        } catch (error) {
            console.error("正解音の再生中にエラーが発生しました:", error);
            // エラー発生時も作成されたノードをクリーンアップ
            tempAudioNodes.forEach(item => {
                if (item.type === 'oscillator' && item.node.stop) {
                    try { item.node.stop(); } catch (e) {}
                }
                try { item.node.disconnect(); } catch (e) {}
            });
            tempAudioNodes = [];
        }
    }

    // --- 答え合わせフェーズ ---
    function checkAnswer() {
        let score = 0;
        let explanation = '';
        const maxScore = 100;
        let currentModuleScore = 0;
        const paramMatchBonus = 5; // パラメータ一致ごとのボーナス
        const typeMatchBonus = 10; // タイプ一致ボーナス
        const modulePresencePenalty = -15; // モジュール不足/過剰ペナルティ

        const userModulesSorted = modules
            .filter(m => m.type !== 'output')
            .sort((a, b) => a.id - b.id); // ユーザーモジュールをID順にソート（接続順の代替）

        const correctModulesConfig = correctAnswer.modulesConfig;

        explanation += `正解のモジュール構成: ${correctModulesConfig.map(cm => cm.type).join(' -> ')}\n`;
        explanation += `あなたのモジュール構成: ${userModulesSorted.map(um => um.type).join(' -> ')}\n\n`;

        let correctModuleIndex = 0;
        let userModuleIndex = 0;

        // モジュールの数と順序の基本的な比較
        if (userModulesSorted.length === correctModulesConfig.length) {
            score += 10; // モジュール数が一致すれば基本点
            explanation += "モジュールの数は正解と一致しています。\n";
        } else {
            explanation += `モジュールの数が異なります。正解: ${correctModulesConfig.length}, あなた: ${userModulesSorted.length}\n`;
            score += (correctModulesConfig.length - Math.abs(correctModulesConfig.length - userModulesSorted.length)) / correctModulesConfig.length * 10; // 数が近いほど少し加点
        }
        
        // 各モジュールのタイプとパラメータを比較
        correctModulesConfig.forEach((correctModule, cIdx) => {
            explanation += `\n正解モジュール ${cIdx + 1}: ${correctModule.type}\n`;
            const userModule = userModulesSorted.find(um => um.type === correctModule.type && !um.alreadyChecked); // タイプが一致し、まだチェックされていないものを探す

            if (userModule) {
                userModule.alreadyChecked = true; // チェック済みマーク
                score += typeMatchBonus;
                explanation += `  あなたの対応するモジュール: ${userModule.name} (タイプ一致: +${typeMatchBonus}点)\n`;

                let moduleParamScore = 0;
                let correctParamsCount = 0;
                let checkedParamsCount = 0;

                for (const paramName in correctModule.params) {
                    checkedParamsCount++;
                    if (userModule.params.hasOwnProperty(paramName)) {
                        const correctValue = correctModule.params[paramName];
                        const userValue = userModule.params[paramName];
                        let paramMatches = false;

                        if (typeof correctValue === 'number') {
                            const tolerance = paramName === 'gain' || paramName === 'feedback' || paramName === 'q' ? 0.15 : (paramName === 'delayTime' ? 0.1 : 20); // 周波数は±20Hz, Gain/Feedback/Qは±0.15, Delayは±0.1s
                            if (Math.abs(correctValue - userValue) <= tolerance) {
                                paramMatches = true;
                            }
                        } else if (typeof correctValue === 'string') {
                            if (correctValue.toLowerCase() === userValue.toLowerCase()) {
                                paramMatches = true;
                            }
                        }

                        if (paramMatches) {
                            moduleParamScore += paramMatchBonus;
                            correctParamsCount++;
                            explanation += `    パラメータ '${paramName}': 一致 (正解: ${correctValue}, あなた: ${userValue}) (+${paramMatchBonus}点)\n`;
                        } else {
                            explanation += `    パラメータ '${paramName}': 不一致 (正解: ${correctValue}, あなた: ${userValue})\n`;
                        }
                    } else {
                        explanation += `    パラメータ '${paramName}': あなたのモジュールには見つかりません。\n`;
                    }
                }
                score += moduleParamScore;
                if (checkedParamsCount > 0 && correctParamsCount === checkedParamsCount) {
                    score += 5; // 全パラメータ一致ボーナス
                    explanation += `  全パラメータ一致ボーナス: +5点\n`;
                }

            } else {
                explanation += `  正解の ${correctModule.type} モジュールがあなたの構成に見つかりません。(ペナルティ適用の場合あり)\n`;
                score += modulePresencePenalty;
            }
        });
        
        // ユーザーが使用したが正解にはないモジュール
        userModulesSorted.filter(um => !um.alreadyChecked).forEach(extraUserModule => {
            explanation += `\n余分なモジュール: ${extraUserModule.name} (${extraUserModule.type}) (ペナルティ適用の場合あり)\n`;
            score += modulePresencePenalty;
        });
        
        // スコアを0〜100の範囲に収める
        score = Math.max(0, Math.min(score, maxScore));

        // チェック済みマークをリセット
        modules.forEach(m => m.alreadyChecked = false);

        alert(`スコア: ${Math.round(score)}/${maxScore}\n\n詳細:\n${explanation}`);
        // displayCorrectAnswerDetails(); // こちらも modulesConfig に合わせた表示に修正が必要
    }

    // --- 正解音を聞くボタンと答え合わせボタンを追加 ---
    const globalControls = document.getElementById('global-controls');
    const playAnswerButton = document.createElement('button');
    playAnswerButton.textContent = '正解音を聞く';
    playAnswerButton.className = 'control-button control-button-green';
    playAnswerButton.addEventListener('click', playCorrectAnswer);
    globalControls.appendChild(playAnswerButton);

    const checkAnswerButton = document.createElement('button');
    checkAnswerButton.textContent = '答え合わせ';
    checkAnswerButton.className = 'control-button control-button-gray';
    checkAnswerButton.addEventListener('click', checkAnswer);
    globalControls.appendChild(checkAnswerButton);
</script>
</body>
</html>
